<html>
    <head>
        <script>
            'use strict';


            const PUZZLE_DATA = {
                "numRows": 15,
                "numCols": 15,
                "answers": "v______________" +
                    "aardvark_______" +
                    "n_e_o__________" +
                    "a_b_ligaments__" +
                    "drake_a___e____" +
                    "i_r___l__ever__" +
                    "u_____l___e____" +
                    "m___score_r____" +
                    "____a__a__l____" +
                    "____w__puma____" +
                    "_____o____norad" +
                    "___edgelord____" +
                    "_____r_________" +
                    "_____e_________" +
                    "_____s_________",
                "clues": [
                    {"row": 0, "col": 0, "hint": "Rare metal", "num": 1, "dir": "down"},
                    {"row": 1, "col": 0, "hint": "First entry in any encyclopedia", "num": 2, "dir": "across"},
                    {"row": 1, "col": 2, "hint": "To concrete structures as bones are to bodies", "num": 3, "dir": "down"},
                    {"row": 1, "col": 4, "hint": "Small rodent that rhymes with its more popular cousin", "num": 4, "dir": "down"},
                    {"row": 3, "col": 4, "hint": "What holds dem bones together", "num": 5, "dir": "across"},
                    {"row": 4, "col": 0, "hint": "Huey, Dewey, Louie, but not Daisy", "num": 6, "dir": "across"},
                    {"row": 3, "col": 6, "hint": "Cheap wine", "num": 7, "dir": "down"},
                    {"row": 3, "col": 10, "hint": "Home for Peter and pirates", "num": 8, "dir": "down"},
                    {"row": 5, "col": 9, "hint": "Always", "num": 9, "dir": "across"},
                    {"row": 7, "col": 4, "hint": "Something for settling", "num": 10, "dir": "across"},
                    {"row": 7, "col": 4, "hint": "Movie series featuring a Goldbergian psychopath", "num": 10, "dir": "down"},
                    {"row": 7, "col": 7, "hint": "Shoot the breeze", "num": 11, "dir": "down"},
                    {"row": 9, "col": 7, "hint": "Cougar, mountain lion, ...", "num": 12, "dir": "across"},
                    {"row": 10, "col": 10, "hint": "Santa tracking entity", "num": 13, "dir": "across"},
                    {"row": 11, "col": 3, "hint": "Internet provocateur", "num": 14, "dir": "across"},
                    {"row": 10, "col": 5, "hint": "Shrek and friends", "num": 15, "dir": "down"}
                ]
            };

            const CLUE_HEIGHT = 15;

            let numRows = 0;
            let numCols = 0;
            let cellWidth = 0;
            let cellHeight = 0;
            let solved = false;
            let canvas = null;
            let context = null;
            let showMistakes = true;
            let answerSquares = '';
            let clues = [];
            let currentSquares = '';
            let startSquares = [];
            let focusRow = 0;
            let focusCol = 0;
            let currentWordStart = 0;
            let currentWordEnd = 0;
            let currentWordDir = 'down';
            let currentClue = 0;

            function init() {
                canvas = document.getElementById('c');
                context = canvas.getContext('2d');
                document.onkeydown = handleKeyDown;
                document.onmousedown = handleMouseDown;
                loadPuzzle(PUZZLE_DATA);
            }

            function loadPuzzle(puzzle) {
                numRows = puzzle.numRows;
                numCols = puzzle.numCols;
                cellWidth = Math.floor(canvas.width / numCols);
                cellHeight = Math.floor((canvas.height - CLUE_HEIGHT) / numRows);
                answerSquares = puzzle.answers;
                currentSquares = answerSquares.replaceAll(/[^_]/gi, ' ');

                startSquares = [];
                for (let i = 0; i < numRows * numCols; i++) {
                    startSquares.push(-1);
                }

                clues = puzzle.clues;
                for (const clue of puzzle.clues) {
                    startSquares[clue.row * numCols + clue.col] = clue.num;
                }

                updateFocus();
            }

            function getCellValue(row, col) {
                return currentSquares[row * numCols + col];
            }

            function setCellValue(row, col, val) {
                const offset = focusRow * numCols + focusCol;
                currentSquares = currentSquares.slice(0, offset) +
                    val + currentSquares.slice(offset + 1);
            }

            function getExpectedValue(row, col) {
                return answerSquares[row * numCols + col];
            }

            function render() {
                context.clearRect(0, 0, canvas.width, canvas.height);

                // Draw focus highlight
                if (!solved) {
                    context.fillStyle = '#b2bfdd';
                    if (currentWordDir == 'across') {
                        context.fillRect(currentWordStart * cellWidth, focusRow * cellHeight,
                                        (currentWordEnd - currentWordStart + 1) * cellWidth,
                                        cellHeight);
                    } else {
                        context.fillRect(focusCol * cellWidth, currentWordStart * cellHeight,
                                        cellWidth,
                                        (currentWordEnd - currentWordStart + 1) * cellHeight);
                    }
                }

                for (let rowi = 0; rowi < numRows; rowi++) {
                    for (let coli = 0; coli < numCols; coli++) {
                        const ch = getCellValue(rowi, coli).toUpperCase();
                        if (ch == '_') {
                            context.fillStyle = 'black';
                            context.fillRect(coli * cellWidth, rowi * cellHeight,
                                             cellWidth, cellHeight);
                        } else {
                            if (rowi == focusRow && coli == focusCol && !solved) {
                                context.fillStyle = '#596fa1';
                                context.fillRect(coli * cellWidth, rowi * cellHeight,
                                                 cellWidth, cellHeight);
                            }

                            if (showMistakes && getExpectedValue(rowi, coli).toUpperCase() != ch) {
                                context.fillStyle = 'red';
                            } else {
                                context.fillStyle = 'black';
                            }

                            context.font = '16pt monospace';
                            context.fontWeight = 'bold';
                            const metrics = context.measureText(ch);
                            const x = coli * cellWidth + (cellWidth - metrics.width) / 2;
                            const glyphHeight = metrics.fontBoundingBoxAscent +
                                                metrics.fontBoundingBoxDescent;
                            const y = rowi * cellHeight + (cellHeight - glyphHeight) / 2 +
                                            metrics.fontBoundingBoxAscent;
                            context.fillText(ch, x, y);

                            const startNum = startSquares[rowi * numCols + coli];
                            if (startNum != -1) {
                                context.fillStyle = 'black';
                                context.font = '8pt monospace';
                                context.fontWeight = 'normal';
                                context.fillText(startNum.toString(), coli * cellWidth + 2,
                                                 rowi * cellHeight + 10);
                            }
                        }
                    }
                }

                if (!solved) {
                    context.fillStyle = 'black';
                    context.font = '12pt monospace';
                    context.fontWeight = 'bold';
                    const clue = clues[currentClue];
                    context.fillText(clue.num + '. ' + clue.hint, 5, canvas.height - 6);
                }

                // Draw grid
                context.beginPath();
                context.strokeStyle = 'gray';
                context.lineWidth = 1;
                for (let rowi = 0; rowi <= numRows; rowi++) {
                    const y = cellHeight * rowi;
                    context.moveTo(0, y);
                    context.lineTo(numCols * cellWidth, y);
                }

                for (let coli = 0; coli <= numCols; coli++) {
                    const x = cellWidth * coli;
                    context.moveTo(x, 0);
                    context.lineTo(x, numRows * cellHeight);
                }

                context.stroke();
            }

            function updateFocus() {
                findHighlightWord();
                render();
            }

            function navigateRight() {
                for (let i = focusCol + 1; i < numCols; i++) {
                    if (getCellValue(focusRow, i) != '_') {
                        focusCol = i;
                        updateFocus();
                        break;
                    }
                }
            }

            function navigateLeft() {
                for (let i = focusCol - 1; i >= 0; i--) {
                    if (getCellValue(focusRow, i) != '_') {
                        focusCol = i;
                        updateFocus();
                        break;
                    }
                }
            }

            function navigateUp() {
                for (let i = focusRow - 1; i >= 0; i--) {
                    if (getCellValue(i, focusCol) != '_') {
                        focusRow = i;
                        updateFocus();
                        break;
                    }
                }
            }

            function navigateDown() {
                for (let i = focusRow + 1; i < numRows; i++) {
                    if (getCellValue(i, focusCol) != '_') {
                        focusRow = i;
                        updateFocus();
                        break;
                    }
                }
            }

            function handleKeyDown(event) {
                if (solved) {
                    return;
                }

                switch (event.key) {
                    case 'ArrowDown':
                        navigateDown();
                        break;
                    case 'ArrowRight':
                        navigateRight();
                        break;
                    case 'ArrowUp':
                        navigateUp();
                        break;
                    case 'ArrowLeft':
                        navigateLeft();
                        break;
                    case ' ':
                        swapHighlightDirection();
                        break;
                    case 'Tab':
                        event.preventDefault();
                        currentClue++;
                        if (currentClue >= clues.length) {
                            currentClue = 0;
                        }

                        focusRow = clues[currentClue].row;
                        focusCol = clues[currentClue].col;
                        currentWordDir = clues[currentClue].dir;
                        findHighlightWord();
                        findNextUnfilled();
                        render();
                        break;
                    case 'Backspace':
                        backspace();
                        break;
                    default: {
                        if (event.key.length == 1) {
                            const code = event.key.charCodeAt(0);
                            if ((code > 47 && code < 58) || (code > 64 && code < 91) ||
                                (code > 96 && code < 123)) {
                                    enterLetter(event.key);
                            }
                        }

                        break;
                    }
                }
            }

            function enterLetter(val) {
                setCellValue(focusRow, focusCol, val);
                findNextUnfilled();
                updateFocus();

                if (answerSquares == currentSquares) {
                    solved = true;
                    render();
                }
            }

            function swapHighlightDirection() {
                if (currentWordDir == 'across') {
                    currentWordDir = 'down';
                } else {
                    currentWordDir = 'across';
                }
                updateFocus();
            }

            function backspace() {
                setCellValue(focusRow, focusCol, ' ');
                if (currentWordDir == 'across') {
                    if (focusCol > 0 &&
                        getCellValue(focusRow, focusCol - 1) != '_') {
                        focusCol--;
                    }
                } else {
                    if (focusRow > 0 &&
                        getCellValue(focusRow - 1, focusCol) != '_') {
                        focusRow--;
                    }
                }

                render();
            }

            function findNextUnfilled() {
                if (currentWordDir == 'across') {
                    let newCol = focusCol;
                    while (newCol < numCols) {
                        const val = getCellValue(focusRow, newCol);
                        if (val == '_') {
                            // No more blanks remaining
                            break;
                        } else  if (val == ' ') {
                            focusCol = newCol;
                            break;
                        }

                        newCol++;
                    }
                } else {
                    let newRow = focusRow;
                    while (newRow < numRows) {
                        const val = getCellValue(newRow, focusCol);
                        if (val == '_') {
                            // No more blanks remaining
                            break;
                        } else  if (val == ' ') {
                            focusRow = newRow;
                            break;
                        }

                        newRow++;
                    }
                }
            }

            function handleMouseDown(event) {
                if (solved) {
                    return;
                }

                const clickCol = Math.floor(event.x / cellWidth);
                const clickRow = Math.floor(event.y / cellHeight);
                if (clickCol >= 0 && clickCol < numCols && clickRow >= 0 && clickRow < numRows) {
                    if (currentSquares[clickRow * numCols + clickCol] != '_') {
                        focusRow = clickRow;
                        focusCol = clickCol;
                        updateFocus();
                    }
                }
            }

            function findWordBoundaries() {
                let left = focusCol;
                while (left > 0 && getCellValue(focusRow, left - 1) != '_') {
                    left--;
                }

                let right = focusCol;
                while (right < numCols - 1 && getCellValue(focusRow, right + 1) != '_') {
                    right++;
                }

                let top = focusRow;
                while (top > 0 && getCellValue(top - 1, focusCol) != '_') {
                    top--;
                }

                let bottom = focusRow;
                while (bottom < numRows - 1 && getCellValue(bottom + 1, focusCol) != '_') {
                    bottom++;
                }

                return [left, top, right, bottom];
            }

            function findHighlightWord() {
                let [left, top, right, bottom] = findWordBoundaries();
                if (left == right && left == focusCol) {
                    // There is no horizontal word
                    currentWordDir = 'down';
                } else if (bottom == top && bottom == focusRow) {
                    // There is no vertical word
                    currentWordDir = 'across';
                }

                // else there is both a horizontal and vertical word here and
                // currentWordDir remains what it was previously.
                if (currentWordDir == 'down') {
                    currentWordStart = top;
                    currentWordEnd = bottom;
                } else {
                    currentWordStart = left;
                    currentWordEnd = right;
                }

                // Find the corresponding clue
                findCurrentClue();
            }

            function findCurrentClue() {
                currentClue = -1;
                for (let i = 0; i < clues.length; i++) {
                    const clue = clues[i];
                    if (currentWordDir == 'down') {
                        if (clue.dir == 'down' && clue.col == focusCol && clue.row == currentWordStart) {
                            currentClue = i;
                            break;
                        }
                    } else {
                        if (clue.dir == 'across' && clue.row == focusRow && clue.col == currentWordStart) {
                            currentClue = i;
                            break;
                        }
                    }
                }
            }
        </script>
    </head>
    <body onload="init()">
        <canvas id="c" width="600" height="620"></canvas>
        <div id="hint"></div>
    </body>
</html>